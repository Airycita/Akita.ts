"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Timeouts = void 0;
const tslib_1 = require("tslib");
const midb_1 = require("midb");
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
class Timeouts extends tiny_typed_emitter_1.TypedEmitter {
    restore;
    db;
    constructor(options) {
        super();
        this.restore = options?.restore ?? true;
        (this.db = new midb_1.Database()).start();
    }
    async update_timeouts(timeouts) {
        await this.db.set('timeouts', timeouts);
    }
    async get_timeouts() {
        return (await this.db.get('timeouts')) || [];
    }
    async add(ms, id, data) {
        let list = await this.get_timeouts();
        let t = { "id": id, "time": ms, "expires": Date.now() + ms, "data": data };
        list.push(t);
        await this.update_timeouts(list);
        this.emit('create', t);
        this.set_expire(t, t.time);
    }
    async remove(timeout) {
        let list = await this.get_timeouts();
        this.update_timeouts(list.filter(t => !lodash_1.default.isEqual(t, timeout)));
    }
    async set_expire(timeout, time) {
        setTimeout(() => { this.out_now(timeout); }, time);
    }
    async out_now(timeout) {
        let list = await this.get_timeouts();
        await this.remove(timeout);
        if (list.find(t => t.id === timeout.id))
            this.emit('expires', timeout);
    }
    async start() {
        let list = await this.get_timeouts();
        for (const timeout of list) {
            if (Date.now() >= timeout.expires) {
                await this.remove(timeout);
                if (this.restore)
                    this.emit('expires', timeout);
            }
            else {
                this.set_expire(timeout, timeout.expires - Date.now());
            }
        }
    }
}
exports.Timeouts = Timeouts;
exports.default = { Timeouts };
